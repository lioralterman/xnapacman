//
//  This CSharp output file generated by Managed Package LEX
//  Version:  0.21e (14-July-2006)
//  Machine:  LAPTOP
//  DateTime: 2010-04-03 19:51:08
//  UserName: noisy
//  MPLEX input file <lexer.lex>
//  MPLEX frame file <C:\Program Files\Visual Studio 2005 SDK\2007.02\VisualStudioIntegration\Tools\bin\mplex.frame>
//

//
// mplex.frame
// Version 0.3.1 of 19-July-2006. 
// Left and Right Anchored state support.
// Start condition stack. Two generic params.
//
using System;
using System.IO;
using System.Collections.Generic;

using Babel.ParserGenerator;
using Babel;
using Babel.Parser;

namespace Babel.Lexer
{   
    /// <summary>
    /// Summary Canonical example of MPLEX automaton
    /// </summary>
    
    public sealed class Scanner : ScanBase
    {
        enum Result {accept, noMatch, contextFound};

        const int maxAccept = 41;
        const int initial = 42;
        const int eofNum = 0;
        const int INITIAL = 0;
        const int COMMENT = 1;

int GetIdToken(string txt)
         {
            switch (txt[0])
            {
                case 'b':
                    if (txt.Equals("break")) return (int)Tokens.KWBREAK;
                    break;
                case 'c':
                    if (txt.Equals("continue")) return (int)Tokens.KWCONTINUE;
                    break;
                case 'e':
                    if (txt.Equals("else")) return (int)Tokens.KWELSE;
                    else if (txt.Equals("extern")) return (int)Tokens.KWEXTERN;
                    break;
                case 'f':
                    if (txt.Equals("for")) return (int)Tokens.KWFOR;
                    break;
                case 'i':
                    if (txt.Equals("if")) return (int)Tokens.KWIF;
                    else if (txt.Equals("int")) return (int)Tokens.KWINT;
                    break;
                 case 'r':
                    if (txt.Equals("return")) return (int)Tokens.KWRETURN;
                    break;
                case 's':
                    if (txt.Equals("static")) return (int)Tokens.KWSTATIC;
                    break;
                case 'v':
                    if (txt.Equals("void")) return (int)Tokens.KWVOID;
                    break;
                case 'w':
                    if (txt.Equals("while")) return (int)Tokens.KWWHILE;
                    break;
                default: 
                    break;
            }
            return (int)Tokens.IDENTIFIER;
       }
       
       internal void LoadYylval()
       {
           yylval.str = tokTxt;
           yylloc = new LexLocation(tokLin, tokCol, tokLin, tokCol + tokLen);
       }
       
       public override void yyerror(string s, params object[] a)
       {
           if (handler != null) handler.AddError(s, tokLin, tokCol, tokLin, tokCol + tokLen);
       }
        int state;
        int currentStart = initial;
        int chr;           // last character read
        int cPos;          // position of chr
        int lNum = 0;      // current line number
        int lineStart;     // start of line

        int tokPos;
        int tokLen;
        int tokCol;
        int tokLin;
        string tokTxt;
        
        private Stack<int> scStack = new Stack<int>();

#region ScannerTables
   struct Table {
        public int min; public int rng; public int dflt;
        public byte[] nxt;
        public Table(int m, int x, int d, byte[] n) {
            min = m; rng = x; dflt = d; nxt = n;
        }
    };

   static int[] startState = {42, 37, 0};

    static Table[] NxS = new Table[43];

    static Scanner() {
    NxS[0] = new Table(0, 0, 0, null);
    NxS[1] = new Table(0, 0, 42, null);
    NxS[2] = new Table(9, 24, 42, new byte[] {36, 42, 36, 36, 36, 42, 
        42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
        42, 36});
    NxS[3] = new Table(0, 0, 42, null);
    NxS[4] = new Table(61, 1, 42, new byte[] {35});
    NxS[5] = new Table(38, 1, 42, new byte[] {34});
    NxS[6] = new Table(0, 0, 42, null);
    NxS[7] = new Table(0, 0, 42, null);
    NxS[8] = new Table(0, 0, 42, null);
    NxS[9] = new Table(0, 0, 42, null);
    NxS[10] = new Table(0, 0, 42, null);
    NxS[11] = new Table(0, 0, 42, null);
    NxS[12] = new Table(0, 0, 42, null);
    NxS[13] = new Table(42, 1, 42, new byte[] {30});
    NxS[14] = new Table(48, 10, 42, new byte[] {29, 29, 29, 29, 29, 29, 
        29, 29, 29, 29});
    NxS[15] = new Table(0, 0, 42, null);
    NxS[16] = new Table(61, 1, 42, new byte[] {28});
    NxS[17] = new Table(61, 1, 42, new byte[] {27});
    NxS[18] = new Table(61, 1, 42, new byte[] {26});
    NxS[19] = new Table(48, 75, 42, new byte[] {25, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 42, 42, 42, 42, 42, 42, 42, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25, 42, 42, 42, 42, 25, 42, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25});
    NxS[20] = new Table(0, 0, 42, null);
    NxS[21] = new Table(0, 0, 42, null);
    NxS[22] = new Table(124, 1, 42, new byte[] {24});
    NxS[23] = new Table(0, 0, 42, null);
    NxS[24] = new Table(0, 0, 42, null);
    NxS[25] = new Table(48, 75, 42, new byte[] {25, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 42, 42, 42, 42, 42, 42, 42, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25, 42, 42, 42, 42, 25, 42, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
        25, 25, 25, 25, 25});
    NxS[26] = new Table(0, 0, 42, null);
    NxS[27] = new Table(0, 0, 42, null);
    NxS[28] = new Table(0, 0, 42, null);
    NxS[29] = new Table(48, 10, 42, new byte[] {29, 29, 29, 29, 29, 29, 
        29, 29, 29, 29});
    NxS[30] = new Table(10, 33, 31, new byte[] {42, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32});
    NxS[31] = new Table(10, 33, 31, new byte[] {42, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32});
    NxS[32] = new Table(42, 6, 42, new byte[] {32, 42, 42, 42, 42, 33});
    NxS[33] = new Table(0, 0, 42, null);
    NxS[34] = new Table(0, 0, 42, null);
    NxS[35] = new Table(0, 0, 42, null);
    NxS[36] = new Table(9, 24, 42, new byte[] {36, 42, 36, 36, 36, 42, 
        42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
        42, 36});
    NxS[37] = new Table(10, 33, 38, new byte[] {39, 38, 38, 38, 38, 38, 
        38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
        38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 40});
    NxS[38] = new Table(10, 33, 38, new byte[] {37, 38, 38, 38, 38, 38, 
        38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
        38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 40});
    NxS[39] = new Table(0, 0, 37, null);
    NxS[40] = new Table(42, 6, 37, new byte[] {40, 37, 37, 37, 37, 41});
    NxS[41] = new Table(0, 0, 37, null);
    NxS[42] = new Table(9, 117, 1, new byte[] {2, 3, 2, 2, 2, 1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 2, 4, 1, 1, 1, 1, 5, 1, 6, 7, 8, 9, 10, 11, 12, 
        13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 1, 15, 16, 17, 18, 
        1, 1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 1, 1, 1, 20, 
        19, 1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 21, 22, 23});
    }

int NextState(int qStat) {
    if (chr == ScanBuff.EOF)
        return (qStat <= maxAccept && qStat != currentStart ? currentStart : eofNum);
    else {
        uint idx = (uint)(chr - NxS[qStat].min);
        if (idx >= (uint)NxS[qStat].rng) return NxS[qStat].dflt;
        else return NxS[qStat].nxt[idx];
    }
}

int NextState() {
    if (chr == ScanBuff.EOF)
        return (state <= maxAccept && state != currentStart ? currentStart : eofNum);
    else {
        uint idx = (uint)(chr - NxS[state].min);
        if (idx >= (uint)NxS[state].rng) return NxS[state].dflt;
        else return NxS[state].nxt[idx];
    }
}
#endregion

        public ScanBuff buff;
        private IErrorHandler handler;

        // ====================== Nested class ==========================

        public abstract class ScanBuff
        {
            public const char EOF = (char)256;
            public abstract int BuffPos { get; set; }
            public abstract int Read(); // and advance the buffer pointer
            public abstract int Peek(); // but do not advance the pointer
            public abstract string GetString(int begin, int end);
        }

#if BACKUP
        // ====================== Nested class ==========================

        internal class Context // class used for automaton backup.
        {
            public int bPos;
            public int cPos;
            public int state;
            public int cChr;
        }
#endif // BACKUP


        // ====================== Nested class ==========================

        public sealed class StringBuff : ScanBuff
        {
            string str;        // input buffer
            int bPos;          // current position in buffer
            int sLen;

            public StringBuff(string str)
            {
                this.str = str;
                this.sLen = str.Length;
            }

            public override int Read()
            {
                if (bPos < sLen) return str[bPos++];
                else if (bPos == sLen) { bPos++; return '\n'; }   // one strike, see newline
                else return EOF;                                  // two strikes and you're out!
            }

            public override int Peek()
            {
                if (bPos < sLen) return str[bPos];
                else return '\n';
            }

            public override string GetString(int beg, int end)
            {
                if (beg >= sLen || end <= beg) return ""; 
                return str.Substring(beg, end - beg);
            }

            public override int BuffPos
            {
                get { return bPos; }
                set { bPos = value; }
            }
        }

        // ====================== Nested class ==========================

        public sealed class StreamBuff : ScanBuff
        {
            BufferedStream bStrm;   // input buffer

            public StreamBuff(Stream str)
            {
                this.bStrm = new BufferedStream(str);
            }

            // ~StreamBuff() { bStrm.Close(); }

            public override int Read()
            {
                int byt = bStrm.ReadByte();
                if (byt == -1) return EOF;
                else return byt;
            }

            public override int Peek()
            {
                int rslt = Read();
                bStrm.Seek(-1, SeekOrigin.Current);
                return rslt;
            }

            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                return new String(arr);
            }

            public override int BuffPos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }

        // =================== End Nested classes =======================

        public Scanner(Stream file) {
            buff = new StreamBuff(file);
            this.handler = null;
            this.cPos = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }

        public Scanner() 
        { 
            this.handler = null;
        }

        void GetChr()
        {
            if (chr == '\n') { lineStart = buff.BuffPos; lNum++; }
            chr = buff.Read(); cPos++;
        }

        bool AtEnd() { return (chr == (int)'\n' || chr == (int)'\r'); }

        void MkToken(int start, int end)
        {
            tokTxt = null;
            tokPos = start;
            tokLen = end - start;
            tokLin = lNum;
            tokCol = start - lineStart;
        }

        // ================ IColorScan Implementation ===================

        public override void SetSource(string source, int offset)
        {
            this.buff = new StringBuff(source);
            this.buff.BuffPos = offset;
            this.cPos = offset - 1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }

        public override int GetNext(ref int scOrd, out int start, out int end)
        {
            int next;
            SetEolState(scOrd);
            this.currentStart = startState[currentScOrd];
            next = Scan();
            start = tokPos;
            end = tokPos + tokLen - 1;
            scOrd = GetEolState();
            return next;
        }

        // ======== IScanner<> Implementation =========

        public override int yylex()
        {
            int next;
            do { next = Scan(); } while (next > (int)Tokens.maxParseToken);
            return next;
        }

        // public LexSpan yylval { get { return tokVal; } }
        public int yyleng { get { return tokLen; } }
        public int yypos { get { return tokPos; } }
        public int yyline { get { return tokLin; } }
        public int yycol { get { return tokCol; } }

        public string yytext
        {
            get 
            {
                if (tokTxt == null) 
                    tokTxt = buff.GetString(tokPos, tokPos + tokLen);
                return tokTxt;
            }
        }

        public void yyless(int n)
        {
            BuffPos = tokPos + n; GetChr();
        }

        public int BuffPos
        {
            get { return buff.BuffPos; }
            set { buff.BuffPos = value;
                  cPos = value - 1; }
        }

        public string GetString(int start, int end) { return buff.GetString(start, end); }

        public IErrorHandler Handler { get { return this.handler; }
                                       set { this.handler = value; }}

        // ============ methods available in actions ==============

        internal int YY_START {
            get { return currentScOrd; }
            set { currentScOrd = value; } 
        }

        // ============== The main tokenizer code =================

        int Scan()
        {
            try {
                for (; ; )
                {
                    int tPos;              // token start position
                    int next;              // next state to enter
                    
#if BACKUP
                    bool inAccept = false; // inAccept ==> current state is an accept state
                    Result rslt = Result.noMatch;
                    // skip "idle" states
#if LEFTANCHORS
                    if (lineStart == cPos &&
                        NextState(anchorState[currentScOrd]) != currentStart)
                        state = anchorState[currentScOrd];
                    else {
                        state = currentStart;
                        while (NextState() == currentStart) {
                            GetChr();
                            if (lineStart == cPos &&
                                NextState(anchorState[currentScOrd]) != currentStart) {
                                state = anchorState[currentScOrd];
                                break;
                            }
                        }
                    }
#else
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif
                    // common code
                    tPos = cPos;
                    while ((next = NextState()) != currentStart)
                        if (inAccept && next > maxAccept) // need to prepare backup data
                        {
                            Context ctx = new Context();
                            rslt = Recurse2(ctx, next);
                            if (rslt == Result.noMatch) RestoreStateAndPos(ctx);
                            // else if (rslt == Result.contextFound) RestorePos(ctx);
                            break;
                        }
                        else
                        {
                            state = next;
                            GetChr();
#if RIGHTANCHORS
                            if (state <= maxAccept && (!rAnchor[state] || AtEnd()))
                                inAccept = true;
#else
                            if (state <= maxAccept) inAccept = true;
#endif
                        }
#else
#if LEFTANCHORS
                    if (lineStart == cPos &&
                        NextState(anchorState[currentScOrd]) != currentStart)
                        state = anchorState[currentScOrd];
                    else {
                        state = currentStart;
                        while (NextState() == currentStart) {
                            GetChr();
                            if (lineStart == cPos &&
                                NextState(anchorState[currentScOrd]) != currentStart) {
                                state = anchorState[currentScOrd];
                                break;
                            }
                        }
                    }
#else
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif
                    tPos = cPos;
                    // common code
                    while ((next = NextState()) != currentStart)
                    {
                        state = next;
                        GetChr();
                    }
#endif
#if RIGHTANCHORS
                    if (state > maxAccept || rAnchor[state] && !AtEnd())
                        state =currentStart;
#else
                    if (state > maxAccept) state = currentStart;
#endif
                    else
                    {
                        MkToken(tPos, cPos);
#region ActionSwitch
    switch (state)
    {
        case eofNum:
            return (int)Tokens.EOF;
        case 1:
yyerror("illegal char");
                             return (int)Tokens.LEX_ERROR;
            break;
        case 2:
        case 36:
return (int)Tokens.LEX_WHITE;
            break;
        case 3:
return (int)Tokens.LEX_WHITE;
            break;
        case 4:
return (int)'!';
            break;
        case 5:
return (int)'&';
            break;
        case 6:
return (int)'(';
            break;
        case 7:
return (int)')';
            break;
        case 8:
return (int)'*';
            break;
        case 9:
return (int)'+';
            break;
        case 10:
return (int)',';
            break;
        case 11:
return (int)'-';
            break;
        case 12:
return (int)'.';
            break;
        case 13:
return (int)'/';
            break;
        case 14:
        case 29:
return (int)Tokens.NUMBER;
            break;
        case 15:
return (int)';';
            break;
        case 16:
return (int)Tokens.LT;
            break;
        case 17:
return (int)'=';
            break;
        case 18:
return (int)Tokens.GT;
            break;
        case 19:
        case 25:
return GetIdToken(yytext);
            break;
        case 20:
return (int)'^';
            break;
        case 21:
return (int)'{';
            break;
        case 22:
return (int)'|';
            break;
        case 23:
return (int)'}';
            break;
        case 24:
return (int)Tokens.BARBAR;
            break;
        case 26:
return (int)Tokens.GTE;
            break;
        case 27:
return (int)Tokens.EQ;
            break;
        case 28:
return (int)Tokens.LTE;
            break;
        case 30:
        case 31:
        case 32:
BEGIN(COMMENT); return (int)Tokens.LEX_COMMENT;
            break;
        case 33:
return (int)Tokens.LEX_COMMENT;
            break;
        case 34:
return (int)Tokens.AMPAMP;
            break;
        case 35:
return (int)Tokens.NEQ;
            break;
        case 37:
        case 38:
        case 39:
        case 40:
return (int)Tokens.LEX_COMMENT;
            break;
        case 41:
BEGIN(INITIAL); return (int)Tokens.LEX_COMMENT;
            break;
        default:
            break;
    }
#endregion
                    }
                }
            } // end try
            finally {
LoadYylval();
            } // end finally
        }

#if BACKUP
        Result Recurse2(Context ctx, int next)
        {
            // Assert: at entry "state" is an accept state AND
            //         NextState(state, chr) != currentStart AND
            //         NextState(state, chr) is not an accept state.
            //
            bool inAccept;
            SaveStateAndPos(ctx);
            state = next;
            if (state == eofNum) return Result.accept;
            GetChr();
            inAccept = false;

            while ((next = NextState()) != currentStart)
            {
                if (inAccept && next > maxAccept) // need to prepare backup data
                    SaveStateAndPos(ctx);
                state = next;
                if (state == eofNum) return Result.accept;
                GetChr(); 
#if RIGHTANCHORS
                inAccept = (state <= maxAccept && (!rAnchor[state] || AtEnd()));
#else
                inAccept = (state <= maxAccept);
#endif
            }
            if (inAccept) return Result.accept; else return Result.noMatch;
        }

        void SaveStateAndPos(Context ctx)
        {
            ctx.bPos  = BuffPos;
            ctx.cPos  = cPos;
            ctx.state = state;
            ctx.cChr = chr;
        }

        void RestoreStateAndPos(Context ctx)
        {
            BuffPos = ctx.bPos;
            cPos = ctx.cPos;
            state = ctx.state;
            chr = ctx.cChr;
        }

        void RestorePos(Context ctx)
        {
            BuffPos = ctx.bPos;
            cPos = ctx.cPos;
        }
#endif // BACKUP

        // ============= End of the tokenizer code ================

        internal void BEGIN(int next)
        {
            currentScOrd = next;
            currentStart = startState[next];
        }
        
        internal void yy_clear_stack()
        {
            scStack.Clear();
        }
        
        internal void yy_push_state(int state)
        {
            scStack.Push(currentScOrd);
            BEGIN(state);
        }
        
        internal void yy_pop_state()
        {
            // Protect against input errors that pop too far ...
            if (scStack.Count > 0) {
				int newSc = scStack.Pop();
				BEGIN(newSc);
            } // Otherwise leave stack unchanged.
        }
        
        internal int yy_top_state()
        {
            return scStack.Peek();
        }

        internal void ECHO()
        {
            Console.Out.Write(yytext);
        }
#region UserCodeSection

/* .... */

#endregion
    } // end class Scanner
} // end namespace
